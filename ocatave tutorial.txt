Basic operations:

comments in octave: %
xor(1,0)- find xor of the two given values
(comparison)1 == 2 - will return 0 as 1 is not equal to 2
(comparison) 1~=2 - 1 is not equal to 2
AND- 1 && 0
OR- 1 || 0

variables:

ex.: a=4;   if i put semicolon it will not print, just assign but if i dont put the semicolon it will print 

disp(): for printing 

sprintf():
ex. a=3.14;
    disp(sprintf('2 decimels: %0.2f',a))
>>2 decimels: 3.14

format long, format long are data types for printing the long and short values of the variables


How to generate a matrix?
A=[1 2;3 4;5 6;7 8]


How to generate a vector?
V=[1;2;3]

How to generate a matrix of only 1s of 2X3 dimension?
ones(2,3)

how to print a matrix of random numbers?
rand(1,3)/randn(1,3)

plot a histogam:  hist()

how to print a 4X4 identity matrix:
eye(4)

Moving data around:

size(A): retruns the size of matrix A
size(A,1): will give the number of rows of A
size(A,2): will give the number of columns of A
lengtht(A): returns the size of longest dimension. ex for 3x2 matrix, it will return 3(but length is usually applied to vector)

pwd shows current directory/path
cd for change directory
ls lists the sub-directories
load 'filename' : to load data file 
who: shows the variables in the current memory
whos: gives the detailed view of the vars in current memory
clear 'variable name' : to clear the particular var from the current memory
save hello.mat v; : this command will save var v in file called hello.mat
clear: will clear everything in current memory
save hello.txt v -ascii   : will save v in hello.txt in human readable format
INDEXING a matrix:
	Consider a matrix A
	Ex A(3,2) will retrun A_32 i.e. i=3,j=2
	A(2,:) will return everything in the second row and A(":,2) will return everything in the second column of A
	A([1 3],:) will return everything from the 1 and third row
	A(:,2)=[10;11;12] will assign these values to the second column of A
	A=[A,[100,101,102]]; will append another column vector to the right
	A(:) will put all elelments of A into single columsn vector
	How to concatenate 2 matrices: A=[], B=[], C=[A B]. 
	  Can aslo do C[A; B]: this will put B below A



Computing on data:

A*B: for multiplication
A.*B: for element wise multiplication
A.^2: element wise squaring
1 ./ v will divide every elelment of v by 1
log(v): find log of v
exp(v): exponential of v
abs(v): absolute of v
-v will return negative of v
A' : gives the transpose of A
val=max(A): returns maximum element of matrix A
[val,ind]=max(A): will retrun max element and it's index
fnd(a<3); will return the index of the elements that are less than 3
A=magic(3): will retrurn a matrix of 33 dimension whose rows, columns and diagonals have the same sum
sum(a): adds up all the elements of a
prod(a): returns product of all elements of a
floor(a): rounds down
ceil(a): rounds up
max(A,[],1): returns column wise maximum elements; 1 is for telling that we want column wise max
max(A,[],2): returns row wise maximum elements; 2 is for row
sum(A,1): will return sum of each column
sum(A,2): returns sum of each row
flipud(eye(9)): flips the identity matrix or any other matrix
pinv(A) returns inverse of A


Plotting data:

plot(); plot the data
xlabel('time'): labels the x-axis as time
ylabel('values'): labels the y-axis as 'values'
legend('sin',cos'): puts legend on the top right corner
title('my_plot'): puts the title on top of the plot
print -dpng 'myplot.png' to print the graph in png format in the current directory
figure(1) plot(); will create aone instance, figure(2) plot(); will create another instance and so on
subplot(1,2,1): divides the plot into 1x2 grid, and acces first element
clf; clears the figure
imagesc(A): will plot matrix A on a graph
imagesc(A), colorbar, colorbar gray; imagesc plots matrix A, colorbar gray makes the matrix gray and colorbar puts a colorbar on the right that shows the shades of the color i.e gray in this case

Conrol statements and functions:

for loop:
	for i=1:10,
	 v(i)=2^i;
	 end;

while loop:
	i=1;
	while i<=5,
	i=i+1;
	end;

another example,
	i=1;
	while true,
	v(i)=999;
	i=i+1;
	if i==6;
	break;
	end;
	end;

if condition1,
	:
	:
elseif condition2,
	:
	:
else
	:
	:
	end;

Functions:  % addpath('address'): adds a search path

Create a file with  extension .m, define the function there, change the directory in CLI and call the function like: function_xyz(a)


Vectorization:   

consider hypothesis for linear regression:

unvectorized implementation:
	prediction=0.0;
		for j=1 to n+1;
			prediction=prediction+theta(j)*x(j);
		end;

vectorized implementation(ex in octave):
	prediction=theta' * x



	

